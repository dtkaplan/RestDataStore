---
title: "Specifications for Data Store System"
author: "Daniel Kaplan"
date: "December 23, 2014"
output: html_document
---

## Background

My work involves the creation of new approaches to teaching statistics and applied mathematics.  I sometimes describe my job as bringing mathematics education into the 20th century.  (The 21st would be a better goal, but math education rarely gets more recent than the 18th, so there's a long way to go.)  A lot of my work involves outreach to faculty to help them see and exploit the new possibilities.

One of the best ways to support faculty who are trying new topics is to provide problem sets.  Traditionally, this is done via textbooks.  Over the past decade or so, publishers have been putting problem sets online with propietary online scoring systems.  The systems are proprietary because there is no broad industry standard and because the publishers want to make it difficult for faculty to switch to another publisher.

Although there are open-source online scoring systems available, they seem to be very conservative and slow in changing to take advantage of new techologies.  For instance, the most widely used non-proprietary system in mathematics, [WebWork](http://webwork.maa.org/), was designed in the early 1990's, uses a home brew database (in Perl), and doesn't know much about the internet. It also requires a faculty user to upload problems to their own server, which makes version control and updating very difficult.

For the last 10 years, I've been developing and using an open-source interactive-problem system designed to overcome many of these problems.  This has been very much a part-time effort. I have learned a lot about how to make the software maintainable by people like me and accessible to general faculty.

I'm starting work on a dramatically simpler version of the system. I've prototyped it and used it for two years, but now it's time to refactor and clean it up.  

One part of this is a very light-weight database web application.  That's the part of the system that it makes sense to write in Python.  (Everything else is written in R with the Shiny framework for user interfaces.)

## What the system needs

1. Receive requests from a web client to store a new data item and to retrieve one or more items that match a simple criterion.
#. Be lightweight so that it can easily be installed on an up-to-date but generic web service.  
#. Provide simple security of the user ID/Password variety.


## Basic Architure

Client/Server.  Students will have a client of their own to submit and retrieve their own items.  Similarly, faculty will have a client to retrieve items --- grading and such will be handled by the client.  The clients will be written by me (or others) in R/Shiny.

## Data Items

The data item is very simple.  A set of identifiers for finding the items that match a retrieve request, and some string content that will be taken verbatim from the client's store request.

### Identifiers

* Generated by the server:
    a. A unique item ID.
    #. A time stamp
* Provided by the client: 
    a. user ID
    #. a course
    #. a fixed set of several (say, 10) string fields, e.g. ID2, ID3, ID4, ..., ID10, each of which has some string content that's provided by the client. 
    
The identifiers specified by the client are simply strings. What's important about them is that they can be used to search the collection of items and return those that match.

### Content

Just a character string containing, say, JSON formatted data.  Potentially it could be long, e.g. a computer program or even the contents of a file. 
    
## API

The client will have ways to instruct the server:

* to *store* a data item.

* to *receive* a data item.

* to *retrieve* the identifier fields for the whole collection. (That is, the whole collection except fo the content of each item.)

* to *set* any specified identifier fields for one or more items. 

* to *update* the user IDs/passwords by re-reading the URL specified (see below).

## Example

The student will have a client program to display problems and allow him or her to submit answers.  For instance, the student might select "B" as an answer.  This would be submitted for storage to the server, along with the user ID, course, label, and other identifiers.

In reviewing work, the student's client would make a request to the server to retrieve all items with that student's user ID, or perhaps with additional restrictions (e.g. those labeled "Problem 17" in ID5). Any update by the student would be done by making a new submission.

An instructor's client might make request for all items with ID5 labeled "Problem 17," perhaps restricting it further, e.g. ID6 labeled "Stats 155".  The full set of such items would be returned: identifiers and content.

An instructor's client might request that the field ID10 for item 49321 be set to "B+".  It would be nice if such requests could be sent in bulk, e.g. as a table with unique item IDs and the corresponding values for the content of, say, field ID10.

## Form for making requests & submissions.

I'm imaging something like these:

* submit an answer for problem 1 in assignment 2.
    http://server.org/pathToServer/submit?user=Abigail&password=r62ur&course=stat155&ID6=prob18&ID7=assignment2&content=SomeJSONorSuch

* get previous submissions for assignment 2
    http://server.org/pathToServer/retrieve?user=Abigail&password=r62ur&ID7=assignment2

* get student submissions
    http://server.org/pathToServer/Instructor/get?user=Danny&password=redcow&ID7=assignment2
or, to select by time.
    http://server.org/pathToServer/Instructor/get?user=Danny&password=redcow&timestampafter=12-22-2014&timestampbefore=01-17-2015

* set a grade
    http://server.org/pathToServer/Instructor/set?user=Danny&password=redcow&uniqueID=83923&ID10=B
    
* re-read the password URL spreadsheet.
    http://server.org/pathToServer/sync?password=SuperSecretInPyFile

## Security

The server will have hard coded a URL specifying 
* the location of a spreadsheet file, 
* a hard-coded password.  

That spreadsheet will contain user IDs and passwords and authorization (e.g. "Instructor" or "Student").  For each request, the server will check that there is a user/password pair that matches something in the spreadsheet's data. This might involve hashing the password provided in the URL so that it can be compared to the hashed spreadsheet in the password file.  This is not a high priority; the initial hash function can be "keep it as is."

To set or change the hard-coded URL or password, the person will, say, edit the .py file on the server.  Eventually, it would be nice to have a friendlier interface, but that's not important now.

The "sync" command requires the hard-coded password for the system.

The password spreadsheet file will be created and managed by an instructor or other person.  It will have a simple format, e.g.:

userID | passwordHash | authority 
-------|--------------|------------
Susan  | 6l23ks       | student
Danny  | lks2d4       | instructor

## Implementation

I'm imagining that the system will be implemented in Python and an application framework such as `web2py`.  Any system with reasonable performance can be used for storage and retrieval of the items.  My first thought is SQLite or mySQL.  That might be overkill; there will be only one table to store.

## Client for testing

It should be possible to edit URI's by hand or in any other system to access the features of the server.


